DIRECTORY STRUCTURE: .
+f	config.py
+f	data.py
+f	main.py
+f	splash.py
+d	annotater
++f		anno.py
++f		controller.py
++f		player.py
++f		setup.py

d: directory, f: file

FILE CONTENTS:

|||||||||||||		File: config.py		|||||||||||||
# General Imports
import os, time

class Config:
    def __init__(self, cwd=None, in_path=None, out_path=None, files=[]):
        self._cwd = cwd
        self._in_path = in_path
        self._out_path = out_path
        self._files = files
        self._last_update = time.time()

    def update(self, in_path=None, out_path=None, files=[]):
        self.cwd = os.getcwd()
        self.in_path = in_path
        self.out_path = out_path
        self.files = files
        self.last_update = time.time()

    def __str__(self):
        return f"Config: cwd={self.cwd}, in_path={self.in_path}, out_path={self.out_path}, files={self.files}, last_update={self.last_update}"
    
    def __repr__(self):
        return self.__str__()
    
    def __eq__(self, other):
        return self.cwd == other.cwd and self.in_path == other.in_path and self.out_path == other.out_path and self.files == other.files and self.last_update == other.last_update

    @property
    def fetch_top_file(self):
        if len(self.files) == 0:
            return None
        return self.files[0]
    
    def refetch_files(self, inp=None, out=None):
        if inp is not None: self.in_path = inp
        if out is not None: self.out_path = out

        in_path, out_path = self.in_path, self.out_path
        files = [f for f in os.listdir(in_path) if f.endswith(".mp4")]
        files = [f for f in files if f"{f}" not in os.listdir(out_path) if f.endswith(".mp4")]
        # files = [f for f in files if f"{f}_annotated" not in os.listdir(out_path) if f.endswith(".mp4")]
        self.update(in_path, out_path, files)
        return files

    # Properties with getters and setters
    @property
    def cwd(self):
        return self._cwd

    @cwd.setter
    def cwd(self, value):
        self._cwd = value
    
    @property
    def in_path(self):
        return self._in_path

    @in_path.setter
    def in_path(self, value):
        self._in_path = value
    
    @property
    def out_path(self):
        return self._out_path

    @out_path.setter
    def out_path(self, value):
        self._out_path = value
    
    @property
    def files(self):
        return self._files

    @files.setter
    def files(self, value):
        self._files = value
    
    @property
    def last_update(self):
        return self._last_update

    @last_update.setter
    def last_update(self, value):
        self._last_update = value

config = Config()


|||||||||||||		File: data.py		|||||||||||||
# General Imports
import subprocess, cv2, time, json, os
import numpy as np
from functools import lru_cache, cached_property
from customtkinter import filedialog
from tkinter import messagebox
from scipy.io.wavfile import write

class Data:
    """
    Class to store video and audio data, and annotations.

    Parameters:
        - path (str): Path to save video and audio files.
        - name (str): Name of the video file.
        - fps (float): Frames per second of the video.

    Methods:
        - add_video_data(frame): Add video data to the frames list.
        - add_audio_data(audio): Add audio data to the audio list.
        - add_annotation(annotation): Add annotation to the annotations dictionary.
        - save_video_data(): Save video data to a file.
        - save_audio_video_data(): Save audio and video data to a file.
        - save_annotations(): Save annotations to a file.
    """
    def __init__(self, in_path, out_path, name, frame_width, frame_height, fps=30, fc=10225, sample_rate=44100, channels=2):

        def print_data_object_info(name, in_path, out_path, fps, fc, frame_width, frame_height, sample_rate, channels):
            table_data = [
                ["Description", "Value"],
                ["Data Object Created for", name],
                ["Input Path", in_path],
                ["Output Path", out_path],
                ["Name", name],
                ["FPS", fps],
                ["Frame Count", fc],
                ["Frame Width", frame_width],
                ["Frame Height", frame_height],
                ["Sample Rate", sample_rate],
                ["Channels", channels]
            ]

            column_width = max(len(str(item)) for row in table_data for item in row) + 2
            separator = "+" + "-" * (column_width * 2 + 1) + "+"

            print(separator)
            for row in table_data:
                print("|" + "|".join(str(item).center(column_width) for item in row) + "|")
                print(separator)

        print_data_object_info(name, in_path, out_path, fps, fc, frame_width, frame_height, sample_rate, channels)

        self.in_path = in_path      # Path to the video file selected
        self.out_path = out_path    # Path where the video file will be saved
        self.name = name            # Default name of the file (same name as selected file)

        self.in_file_path = os.path.join(in_path, name)    # Full path to the selected video file
        self.out_file_path = os.path.join(out_path, name)  # Full path to the selected video file
        
        self.frame_rate = fps               # Frames per second of the selected video
        self.frame_count = fc               # Frame count of the selected video
        self.frame_width = frame_width      # Width of the frame
        self.frame_height = frame_height    # Height of the frame

        self.frames = []
        self.audio_data =  []
        self.annotations = {}

        self.curr_frame = 0
        self.max_frames = fc

        self.sample_rate = sample_rate
        self.channels = channels
        self.audio_name = self.name.replace(".mp4", ".wav")
        self.audio_path = os.path.join(self.out_path, self.audio_name)

    # METHODS TO COMBINE DATA

    @cached_property
    def combined_audio(self):
        """Combines all audio data into a single array, expensive operation hence cached"""
        return np.concatenate(self.audio_data, axis=0)

    # METHODS TO GET DATA

    @lru_cache(maxsize=128)
    def get_video_frame(self, index):
        return self.frames[index]
    
    @lru_cache(maxsize=128)
    def get_audio_data(self, index):
        return self.audio_data[index]
    
    @lru_cache(maxsize=128)
    def get_annotation(self, timestamp):
        return self.annotations[timestamp]
    
    @cached_property
    def get_curr_frame(self):
        return self.curr_frame
    
    @cached_property
    def get_max_frames(self):
        return self.max_frames
    
    # FRAME HANDLING

    @lru_cache(maxsize=128)
    def get_current_frame(self):
        return self.frames[self.curr_frame]
    
    # MOTHODS TO GET DATA LENGTH

    @cached_property
    def get_frames_length(self):
        return len(self.frames)
    
    @cached_property
    def get_audio_data_length(self):
        return len(self.audio_data)
    
    @cached_property
    def get_annotations_length(self):
        return len(self.annotations)

    # METHODS TO ADD DATA

    def add_curr_frame(self, frame):
        if frame >= self.frame_count:
            print(f"Frame index {frame} is out of range.")
        self.frames.append(frame)

    def add_audio_data(self, audio):
        self.audio_data.append(audio)

    def add_annotation(self, annotation):
        """Adds annotations with timestamp, potentially expensive if called frequently"""
        self.curr_time = time.time()
        time_diff = self.curr_time - self.init_time
        self.annotations[time_diff] = annotation

    # METHODS TO UPDATE DATA

    def update(self, in_path, out_path, name, frame_width, frame_height, fps, fc, sample_rate, channels):
        self.in_path = in_path
        self.out_path = out_path
        self.name = name

        self.in_file_path = os.path.join(in_path, name)
        self.out_file_path = os.path.join(out_path, name)

        self.frame_rate = fps
        self.frame_count = fc
        self.frame_width = frame_width
        self.frame_height = frame_height

        self.sample_rate = sample_rate
        self.channels = channels

    def update_curr_frame(self, frame):
        self.curr_frame = frame

    def update_max_frame(self, frame):
        self.max_frame = frame

    def increment_max_frame(self):
        self.max_frame += 1

    # METHODS TO SAVE DATA

    def process_video_data(self):
        if not self.frames:
            messagebox.showerror("Error", "No frames to save.")
            return

        # open the video file
        cap = cv2.VideoCapture(self.in_file_path)

        # check if the video file is opened
        if not cap.isOpened():
            messagebox.showerror("Error", "Failed to open video file.")
            return
        
        # read the video file frame by frame
        vid, fr_cnt = [], 0
        while True:
            ret, frame = cap.read()
            if not ret:
                break
            vid.append(frame)
            fr_cnt += 1

        # Get original video properties
        original_fps = cap.get(cv2.CAP_PROP_FPS)
        original_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        original_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

        # Assert that the original properties match the given values
        assert original_fps == self.frame_rate, f"FPS mismatch: {original_fps} != {self.frame_rate}"
        assert original_width == self.frame_width, f"Frame width mismatch: {original_width} != {self.frame_width}"
        assert original_height == self.frame_height, f"Frame height mismatch: {original_height} != {self.frame_height}"
        assert fr_cnt == self.frame_count, "Frame count mismatch"

        cap.release()

        fourcc = cv2.VideoWriter_fourcc(*'mp4v')
        out = cv2.VideoWriter(self.out_file_path, fourcc, self.frame_rate, (self.frame_width, self.frame_height))

        # Write frames to the output video in the specified order
        print(f"Writing {len(self.frames)} frames to {self.out_file_path}")
        for index in self.frames:
            if index < len(vid):
                out.write(vid[index])
            else:
                print(f"Warning: Frame index {index} is out of range.")
        print(f"Video saved to {self.out_file_path}")

    def process_audio_data(self):
        # Check if audio data and annotations are present
        if len(self.audio_data) > 0:
            print(f"Saving {len(self.audio_data)} frames of audio data {self.out_path}")
            write(self.audio_path, self.sample_rate, self.combined_audio)

            # TODO : add a logger

            subprocess.run([
                'ffmpeg',
                '-i', self.out_file_path,
                '-i', self.audio_path,
                '-c:v', 'copy',
                '-c:a', 'aac',
                '-strict', 'experimental',
                self.out_file_path.replace('.mp4', '_annotated.mp4')
            ])

    def clean_audio_video_data(self):
        # delete the audio and video data at self.out_file_path and self.audio_path
        if os.path.exists(self.out_file_path):
            os.remove(self.out_file_path)
        if os.path.exists(self.audio_path):
            os.remove(self.audio_path)  

    def save_annotations(self):
        # Save annotations
        if self.annotations:
            """Save annotations to a JSON file"""
            try:
                with open(f"{self.out_path}\\{self.name}_annotations.json", "w") as file:
                    json.dump(self.annotations, file)
            except Exception as e:
                print(f"Error saving annotations: {e}")


    def save_data(self):
        """Function to save video and audio, and merge them using FFmpeg"""
        try:
            if not self.out_path:
                self.out_path = filedialog.askdirectory(filetypes=[("MP4 files", "*.mp4")])

            # TODO : len check
            # # Check if there's audio data and video data synchronization is needed
            # if len(self.audio_data) > 0:
            #     assert len(self.frames) == len(self.audio_data), "Audio and video data are not in sync"

            # Save video data
            self.process_video_data()

            # Save audio data
            self.process_audio_data()

            # Save annotations
            self.save_annotations()

            # Cleanup
            self.clean_audio_video_data()


        except Exception as e:
            print(f"Error saving audio-video-annotation data: {e}")

    # METHODS TO DELETE DATA

    def clean(self):
        """Function to clean the data object"""
        self.frames = []
        self.audio_data = []
        self.annotations = {}
        self.curr_frame = 0
        self.max_frame = 0

|||||||||||||		File: main.py		|||||||||||||
# imports
import customtkinter as ctk
from splash import Splash
from annotater.anno import create_annotater

# TODO: Add draw annotations
# TODO: test Surface audio signal
# TODO: test annotations recorded 240p and recoreded in 1080p, scaled down to 240p

# run main loop
if __name__ == "__main__":

    # Set the theme (optional)
    ctk.set_appearance_mode("Dark")  # Can be "Dark" or "Light"

    # Create the main application window
    app = ctk.CTk()
    app.title("Annotater") # Set the title of the window
    app.protocol("WM_DELETE_WINDOW", lambda: app.destroy())

    # Hide the main application window initially
    app.withdraw()

    # Show splash screen
    splash = Splash(app)

    create_annotater(app)


|||||||||||||		File: splash.py		|||||||||||||
# General Imports
import os, customtkinter as ctk
from PIL import Image

class Splash(ctk.CTkToplevel):
    def __init__(self, root):
        super().__init__(root)
        self.root = root
        self.create_splash(root)
        self.bind("<Configure>", self.update_window_position)
        self.update_countdown(3)

    def create_splash(self, root):
        self.title("Loading...")

        # Center the splash screen
        self.screen_width = self.winfo_screenwidth()
        self.screen_height = self.winfo_screenheight()
        self.window_width = int(self.screen_width // 3)
        self.window_height = int(self.screen_height // 2)
        self.position_top = (self.screen_height // 2) - (self.window_height // 2)
        self.position_right = (self.screen_width // 2) - (self.window_width // 2)
        self.geometry(f"{self.window_width}x{self.window_height}+{self.position_right}+{self.position_top}")

        # Make the splash screen topmost
        self.attributes("-topmost", True)

        # Load and resize the image
        self.image_path = "./imgs/jhu.png"
        self.max_image_width = self.window_width - 40  # Max width for the image with padding
        self.max_image_height = self.window_height // 2  # Max height for the image

        if os.path.exists(self.image_path):
            img = Image.open(self.image_path)
            img_width, img_height = img.size

            # # Debug print statement
            # print(f"Original Image Size: {img_width}x{img_height}")

            # Scale down the image if it is too big
            if img_width > self.max_image_width or img_height > self.max_image_height:
                scaling_factor = min(self.max_image_width / img_width, self.max_image_height / img_height)
                new_width = int(img_width * scaling_factor)
                new_height = int(img_height * scaling_factor)
                img = img.resize((new_width, new_height), Image.Resampling.LANCZOS)

            #     # Debug print statement
            #     print(f"Resized Image Size: {new_width}x{new_height}")

            # print(f"Image size: {img.size}")
            # img_ctk = ImageTk.PhotoImage(img)  # Convert to PhotoImage
            img_ctk = ctk.CTkImage(img, size=(img.width, img.height))  # Convert to CTkImage
            # Create and place the image label
            self.image_label = ctk.CTkLabel(self, text="", image=img_ctk)
            self.image_label.pack(pady=20)
        else:
            print(f"Image not found: {self.image_path}")

        # Create and place the text label
        self.label = ctk.CTkLabel(self, text="Welcome to the Annotater Application", font=("Arial", 16))
        self.label.pack(pady=10)

        self.countdown_label = ctk.CTkLabel(self, text="Closing in 3 seconds", font=("Courier", 12))
        self.countdown_label.pack(pady=10)

        self.window_position_label = ctk.CTkLabel(self, text=f"Window Position: {self.winfo_x()}, {self.winfo_y()}")
        self.window_position_label.pack(pady=2)

    def update_countdown(self, count):
        if count > 0:
            self.countdown_label.configure(text=f"Closing in {count} seconds...")
            self.after(1000, self.update_countdown, count-1)
        else:
            self.destroy_splash()

    def update_window_position(self, event):
        self.window_position_label.configure(text=f"Window Position: {self.winfo_x()}, {self.winfo_y()}")

    def destroy_splash(self):
        self.destroy()
        self.root.deiconify()    # Show the main window


|||||||||||||		File: annotater\anno.py		|||||||||||||
# General Imports
import threading
import customtkinter as ctk
from tkinter import messagebox

# Local Imports
from annotater.player import VideoPlayer
from annotater.setup import file_setup, change_directory
from config import config

def annotate(app, current_file_label):
    file_name = config.fetch_top_file
    if not file_name:
        current_file_label.configure(text="All files have been annotated.")
    else:
        done_event = threading.Event()
        player = VideoPlayer(app, file_name, done_event=done_event)
        done_event.wait()
        _ = config.refetch_files()
        current_file_label.configure(text=f"Current File to be Annotated: {config.fetch_top_file}")

def refresh(current_file_label):
    _ = config.refetch_files()
    current_file_label.configure(text=f"Current File to be Annotated: {config.fetch_top_file}")

def watch():
    # TODO: add logic to watch video
    pass

# Functions
def create_annotater(app):
    app.iconbitmap("./imgs/tool.ico")

    # add default styling options
    ctk.set_default_color_theme("dark-blue")  # Set the default color theme
    # ctk.set_font("Courier", 12)  # Set the default font and size
    app.option_add("*Font", "Courier 12")  # Set the default font and size

    # Set geometry to the full screen
    screen_width = 400
    screen_height = 350
    offset = 1/4
    geo = f"{screen_width}x{screen_height}+{offset*screen_width}+{offset*screen_height}"
    # geo = f"{screen_width}x{screen_height}-9-9"
    print(f"Geometry: {geo}")
    app.geometry(geo)

    # Setup Files
    file_setup()
    
    # Add a label to the window
    change_dir_button = ctk.CTkButton(app, text="Change Directory", command=change_directory)
    change_dir_button.pack(pady=20)

    # Add label for the current file name
    current_file_label = ctk.CTkLabel(app, text=f"Current File to be Annotated: {config.fetch_top_file}")
    current_file_label.pack(pady=20)

    # Open Video Player Button
    video_button = ctk.CTkButton(app, text="Begin Annotating", command=lambda: annotate(app, current_file_label))
    video_button.pack(pady=20)

    # Button to refresh files
    refresh_button = ctk.CTkButton(app, text="Refresh Files", command=lambda: refresh(current_file_label))
    refresh_button.pack(pady=20)

    watch_button = ctk.CTkButton(app, text="Watch Annotated Video", command=lambda: watch())
    watch_button.pack(pady=20)

    # Start the main application loop
    app.mainloop()

|||||||||||||		File: annotater\controller.py		|||||||||||||

# General imports
import cv2
import customtkinter as ctk
from tkinter import DoubleVar

# TODO : Make seeker faster and in real time

class ControlWindow(ctk.CTkToplevel):
    def __init__(self, app, file_name, video_player, *args, **kwargs):
        super().__init__(app, *args, **kwargs)
        self.video_player = video_player
        self.title(f"Video Controls: {file_name}")
        self.control_frame = ctk.CTkFrame(self)
        self.control_frame.pack(pady=10)
        
        self.play_pause_button = ctk.CTkButton(self.control_frame, text="▐▐", command=self.toggle_pause)
        self.play_pause_button.grid(row=0, column=0, padx=5)
        
        self.seek_var = DoubleVar()
        self.seeker = ctk.CTkSlider(self.control_frame, variable=self.seek_var, from_=0, to=int(self.video_player.cap.get(cv2.CAP_PROP_FRAME_COUNT)), command=self.seek)
        self.seeker.grid(row=0, column=1, padx=5, sticky="ew")

        self.restart_button = ctk.CTkButton(self.control_frame, text="↺", command=self.restart)
        self.restart_button.grid(row=0, column=2, padx=5)

        self.stop_button = ctk.CTkButton(self.control_frame, text="■", command=self.save_and_close)
        self.stop_button.grid(row=0, column=3, padx=5)

        self.columnconfigure(1, weight=1)
        self.protocol("WM_DELETE_WINDOW", self.close)
        
        # Make the control window screen topmost
        self.attributes("-topmost", True)

    def add_to_queue(self, command):
        self.video_player.command_queue.put(command)

    def toggle_pause(self):
        self.play_pause_button.configure(text="▶" if self.video_player.paused else "||")
        self.add_to_queue('pause')

    def seek(self, value):
        frame_number = int(value)
        self.add_to_queue(('seek', frame_number))
        self.seek_var.set(frame_number)

    def restart(self):
        self.add_to_queue('restart')
        self.play_pause_button.configure(text="▐▐")
        self.seek_var.set(0)

    def save_and_close(self):
        self.video_player.close(save=True)
        self.video_player.done_event.set()

    def close(self):
        self.video_player.close()
        self.video_player.done_event.set()

|||||||||||||		File: annotater\player.py		|||||||||||||
# General Imports
import cv2, os, time, threading, queue
from tqdm import tqdm
from tkinter import messagebox
import sounddevice as sd

# Local Imports
from data import Data
from config import config
from annotater.controller import ControlWindow

# TODO : add audio callback function
# TODO: setup audio input
# TODO : implement draw_annotation later on in seperate dictionary


class VideoPlayer:
    def __init__(self, app, file_name, done_event):
        
        # Video Player Objects
        self.app = app
        self.cap = None
        self.done_event = done_event  # Event to signal completion

        # Variables
        self.file_path, self.file_name = config.in_path, file_name
        self.cwd, self.out_path = os.getcwd(), config.out_path
        self._data = None
        self.last_frame, self.last_frame_idx, self.last_point = None, None, None

        # FLags
        self.paused, self.drawing = False, False

        # widgets
        self.control_window, self.control_frame = None, None
        self.play_pause_button, self.seeker = None, None

        # Queue for thread-safe communication
        self.command_queue = queue.Queue()
        
        # Lock for thread-safe data updates
        self.lock = threading.Lock()

        # Open the video player
        if not os.path.exists(f"{self.file_path}\{self.file_name}"):
            # check if file exists
            messagebox.showerror("Error", "File not found.")
            return
        else:
            self.cap = cv2.VideoCapture(f"{self.file_path}\{self.file_name}")
            if not self.cap.isOpened():
                messagebox.showerror("Error", "Failed to open video file.")
                return
            
        # get last frame and its index
        self.last_frame_idx = int(self.cap.get(cv2.CAP_PROP_FRAME_COUNT)) - 1
        self.cap.set(cv2.CAP_PROP_POS_FRAMES, self.last_frame_idx)
        _, self.last_frame = self.cap.read()
        
        # reset cap to the first frame
        self.cap.set(cv2.CAP_PROP_POS_FRAMES, 0)

        # Audio variables
        self.samplerate = 44100
        self.channels = 2

        self._data = Data(
            in_path=self.file_path, out_path=self.out_path,
            name=self.file_name, 
            frame_width=int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH)), 
            frame_height=int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT)), 
            fps=int(self.cap.get(cv2.CAP_PROP_FPS)), 
            fc=int(self.cap.get(cv2.CAP_PROP_FRAME_COUNT)),
            sample_rate=self.samplerate, channels=self.channels)
        
        self.frame_delay = int((1 / self._data.frame_rate) * 1000)

        # set up audio stream
        # self.audio_stream = sd.InputStream(samplerate=self.samplerate, channels=self.channels, callback=self.audio_callback)

        # set up video player
        self.video_thread = threading.Thread(target=self.main_loop, daemon=True)

        # Ensure control window is only set up once
        self.control_window = ControlWindow(self.app, self.file_name, self)

        # Start the video player thread
        self.video_thread.start()

        # Start the control window
        self.control_window.mainloop()

    def mouse_callback(self, event, x, y, flags, param):
        print(event, x, y, flags, param)
        # if event == cv2.EVENT_LBUTTONDOWN:
        #     self.paused = not self.paused

    def audio_callback(self, indata, frames, time, status):
        self._data.add_audio_data(indata.copy())

    def main_loop(self):
        cv2.namedWindow("Video Player")
        cv2.setMouseCallback("Video Player", self.mouse_callback)
        # cv2.positio

        total_frames = self._data.max_frames

        # # start audio stream
        # self.audio_stream.start()

        with sd.InputStream(samplerate=self.samplerate, channels=self.channels, callback=self.audio_callback):
            with tqdm(total=total_frames, desc="Processing Frames") as self.pbar:
                while self.cap.isOpened():
                    start_time = time.time()

                    curr_frame = int(self.cap.get(cv2.CAP_PROP_POS_FRAMES))
                    if curr_frame >= total_frames: curr_frame = total_frames - 1
                    
                    # update seeker
                    # self.control_window.seeker.configure(to=curr_frame)
                    self.control_window.seek_var.set(curr_frame)

                    # Check for commands
                    try:
                        command = self.command_queue.get_nowait()

                        if command == 'pause': self.toggle_pause()
                        elif isinstance(command, tuple) and command[0] == 'seek': self.seek(command[1])
                        elif command == 'restart': self.restart()

                    except queue.Empty:
                        pass
                    
                    # Check for pause
                    if not self.paused:
                        ret, frame = self.cap.read()
                        
                        # TODO : think about ending
                        if not ret: 
                            self.pbar.total += 1
                            cv2.imshow("Video Player", self.last_frame)
                        else:
                            cv2.imshow("Video Player", frame)
                    else:
                        self.pbar.total += 1
                        self._data.increment_max_frame()

                    # add current frame to data
                    self._data.add_curr_frame(curr_frame)

                    # Check for key press
                    key = cv2.waitKey(1) & 0xFF
                    print(f"Key: {key}")

                    # Update progress bar
                    self.pbar.update(1)

                    # Update frame delay
                    elapsed_time = time.time() - start_time
                    remaining_time = max(0, self.frame_delay / 1000 - elapsed_time)  # Convert frame_delay to seconds
                    if remaining_time > 0:
                        time.sleep(remaining_time)

    def toggle_pause(self):
        self.paused = not self.paused

    def seek(self, frame_number):
        self.cap.set(cv2.CAP_PROP_POS_FRAMES, frame_number)
        self._data.update_curr_frame(frame_number)

    def restart(self):
        # Reset the video player
        self.paused, self.drawing = False, False

        # reset cap to the first frame
        self.cap.set(cv2.CAP_PROP_POS_FRAMES, 0)

        # clean data
        self._data.clean()
        self._data.update_max_frame(int(self.cap.get(cv2.CAP_PROP_FRAME_COUNT)))
        self._data.update(
            in_path=self.file_path, out_path=self.out_path,
            name=self.file_name, 
            frame_width=int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH)), 
            frame_height=int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT)), 
            fps=int(self.cap.get(cv2.CAP_PROP_FPS)), 
            fc=int(self.cap.get(cv2.CAP_PROP_FRAME_COUNT)),
            sample_rate=self.samplerate, channels=self.channels)
        
        # clear command queue
        while not self.command_queue.empty():
            _ = self.command_queue.get()

        # Reset tqdm progress bar
        self.pbar.reset(total=int(self.cap.get(cv2.CAP_PROP_FRAME_COUNT)))
        self.pbar.refresh()

    def close(self, save=False):
        self.cap.release()
        # self.audio_stream.stop()
        sd.stop()
        if save: self.save()
        cv2.destroyAllWindows()
        self._data = None
        self.done_event.set()
        self.video_thread.join(1)
        self.control_window.quit()
        self.control_window.destroy()
        self.app.deiconify()

    def save(self):
        self._data.save_data()

    # def on_mouse_click(self, event):
    #     if event.num == 1 and self.paused:  # Ensure this happens only if the video is paused
    #         self.drawing = True
    #         self.last_point = (event.x, event.y)
    #     elif not self.paused:
    #         self.drawing = False

    # def on_mouse_move(self, event):
    #     if self.drawing and self.paused:
    #         x, y = event.x, event.y
    #         self._data.add_annotation(((x, y), self.last_point))
    #         self.last_point = (x, y)

|||||||||||||		File: annotater\setup.py		|||||||||||||
# General Imports
import os
from customtkinter import filedialog
from tkinter import messagebox

# Local Imports
from config import config

def file_setup():
    # get current working directory
    cwd = os.getcwd()
    
    # Select Input Video Directory
    if not os.path.exists(f"{cwd}\data"): in_path = filedialog.askdirectory(title="Select Input Directory", initialdir=cwd)
    else: in_path = f"{cwd}\data"

    # Select Output Directory
    if not os.path.exists(f"{cwd}\out"): out_path = filedialog.askdirectory(title="Select Output Directory", initialdir=cwd)
    else: out_path = f"{cwd}\out"

    # get list of names all mp4 files in self.file_path
    in_files = [f for f in os.listdir(in_path) if f.endswith(".mp4")]

    if len(in_files) == 0: 
        messagebox.showerror("Error", "No MP4 files found in the input directory.")
    
    files = config.refetch_files(in_path, out_path)

def change_directory():
    new_directory = filedialog.askdirectory(title="Select New Directory")
    if new_directory:
        os.chdir(new_directory)
        print(f"Current working directory changed to: {new_directory}")
        in_path, out_path, files = file_setup()
        return in_path, out_path, files, new_directory

