DIRECTORY STRUCTURE: .
+f	config.py
+f	data.py
+f	logging_config.yaml
+f	main.py
+f	screens.py
+d	annotater
++f		anno.py
++f		controller.py
++f		player.py
++f		setup.py

d: directory, f: file

FILE CONTENTS:

|||||||||||||		File: config.py		|||||||||||||
# General Imports
import os, time, logging

# Set up logging
logger = logging.getLogger('app')

class Config:
    def __init__(self, cwd=None, in_path=None, out_path=None, files=[], extension=".mp4"):
        self._cwd = cwd
        self._in_path = in_path
        self._out_path = out_path
        self._files = files
        self._last_update = time.time()
        self.extension = extension
        logger.info(f"Config initialized with cwd={self._cwd}, in_path={self._in_path}, out_path={self._out_path}")

    def update(self, in_path=None, out_path=None, files=[]):
        self.cwd = os.getcwd()
        self.in_path = in_path
        self.out_path = out_path
        self.files = files
        self.last_update = time.time()
        logger.info(f"Config updated with in_path={self.in_path}, out_path={self.out_path}")

    def __str__(self):
        return f"Config: cwd={self.cwd}, in_path={self.in_path}, out_path={self.out_path}, files={self.files}, last_update={self.last_update}"
    
    def __repr__(self):
        return self.__str__()
    
    def __eq__(self, other):
        equality = self.cwd == other.cwd and self.in_path == other.in_path and self.out_path == other.out_path and self.files == other.files and self.last_update == other.last_update
        return equality

    @property
    def fetch_top_file(self):
        if len(self.files) == 0:
            return None
        return self.files[0]
    
    def remove_extension(self, file_name, extensions=[".mp4"]):
        for ext in extensions:
            if file_name.endswith(ext):
                logger.debug(f"Removing extension '{ext}' from file '{file_name}'")
                return file_name[:-len(ext)]
        logger.debug(f"No extension removed from file '{file_name}'")
        return file_name
    
    def refetch_files(self, inp=None, out=None, extensions=[".mp4"]):
        try:
            if inp is not None: in_files = [self.remove_extension(f, extensions) for f in os.listdir(inp) if f.endswith(tuple(extensions))]
            if out is not None: out_files = [self.remove_extension(f, extensions) for f in os.listdir(out) if f.endswith(tuple(extensions))]
            files = [f"{f}{self.extension}" for f in in_files if f"{f}_annotated" not in out_files]

            self.update(self.in_path, self.out_path, files)
            logger.info(f"Refetched files: {files}")
            return files
        except Exception as e:
            logger.error(f"Error refetching files: {e}")
            raise e

    # Properties with getters and setters
    @property
    def cwd(self):
        return self._cwd

    @cwd.setter
    def cwd(self, value):
        logger.debug(f"Setting Current Working Directory: {value}")
        self._cwd = value
    
    @property
    def in_path(self):
        return self._in_path

    @in_path.setter
    def in_path(self, value):
        logger.debug(f"Setting input folder path to: {value}")
        self._in_path = value
    
    @property
    def out_path(self):
        return self._out_path

    @out_path.setter
    def out_path(self, value):
        logger.debug(f"Setting output folder path to: {value}")
        self._out_path = value
    
    @property
    def files(self):
        return self._files

    @files.setter
    def files(self, value):
        logger.debug(f"Setting Files: {value}")
        self._files = value
    
    @property
    def last_update(self):
        return self._last_update

    @last_update.setter
    def last_update(self):
        logger.debug(f"Setting last_update: {time.time()}")
        self._last_update = time.time()

config = Config()


|||||||||||||		File: data.py		|||||||||||||
# General Imports
import subprocess, cv2, json, os, logging
import numpy as np
from functools import lru_cache, cached_property
from customtkinter import filedialog
from tkinter import messagebox
from scipy.io.wavfile import write

# Custom Imports
from screens import SaveProgress

# Set up logging
logger = logging.getLogger('app')

class Data:
    """
    Class to store video and audio data, and annotations.

    Parameters:
        - path (str): Path to save video and audio files.
        - name (str): Name of the video file.
        - fps (float): Frames per second of the video.

    Methods:
        - add_video_data(frame): Add video data to the frames list.
        - add_audio_data(audio): Add audio data to the audio list.
        - add_annotation(annotation): Add annotation to the annotations dictionary.
        - save_video_data(): Save video data to a file.
        - save_audio_video_data(): Save audio and video data to a file.
        - save_annotations(): Save annotations to a file.
    """
    def __init__(self, in_path, out_path, name, frame_width, frame_height, fps=30, fc=10225, sample_rate=44100, channels=2):

        self.print_data_object_info(name, in_path, out_path, fps, fc, frame_width, frame_height, sample_rate, channels, log=True)

        self.in_path = in_path      # Path to the video file selected
        self.out_path = out_path    # Path where the video file will be saved
        self.name = name            # Default name of the file (same name as selected file)

        self.in_file_path = os.path.join(in_path, name)    # Full path to the selected video file
        self.out_file_path = os.path.join(out_path, name)  # Full path to the selected video file
        
        self.frame_rate = fps               # Frames per second of the selected video
        self.frame_count = fc               # Frame count of the selected video
        self.frame_width = frame_width      # Width of the frame
        self.frame_height = frame_height    # Height of the frame

        self.frames = []                    # List of (timestamp, frame) tuples
        self.audio_data =  []               # List of (timestamp, audio_chunk) tuples
        self.annotations = {}               # Dictionary of annotations with frame index as key

        self.curr_frame = 0
        self.max_frames = fc

        self.sample_rate = sample_rate
        self.channels = channels
        self.audio_name = self.name.replace(".mp4", ".wav")
        self.audio_path = os.path.join(self.out_path, self.audio_name)

        logger.info(f"Data object for {name} initialized")

    # METHODS TO PRINT DATA

    def print_data_object_info(self, name, in_path, out_path, fps, fc, frame_width, frame_height, sample_rate, channels, log=False):
        table_data = [
            ["Description", "Value"],
            ["Data Object Created for", name],
            ["Input Path", in_path],
            ["Output Path", out_path],
            ["Name", name],
            ["FPS", fps],
            ["Frame Count", fc],
            ["Frame Width", frame_width],
            ["Frame Height", frame_height],
            ["Sample Rate", sample_rate],
            ["Channels", channels]
        ]

        column_width = max(len(str(item)) for row in table_data for item in row) + 2
        separator = "+" + "-" * (column_width * 2 + 1) + "+"

        if log:
            _str = ""
            for row in table_data: _str += "|" + "|".join(str(item).center(column_width) for item in row) + "| "
            logger.debug(_str.rstrip())
        else:
            print(separator)
            for row in table_data:
                print("|" + "|".join(str(item).center(column_width) for item in row) + "|")
                print(separator)

    # METHODS TO GET DATA

    @lru_cache(maxsize=128)
    def get_video_frame(self, index):
        return self.frames[index]
    
    @lru_cache(maxsize=128)
    def get_audio_data(self, index):
        return self.audio_data[index]
    
    def get_annotation(self, frame_idx):
        if frame_idx not in self.annotations: return None
        return self.annotations[frame_idx]
    
    @cached_property
    def get_curr_frame(self):
        return self.curr_frame
    
    def get_last_annotation(self):
        if self.get_frames_length == 0 or self.get_annotations_length == 0:
            return None
        return self.get_annotation(max(self.annotations.keys()))
    
    @property
    def get_max_frames(self):
        return self.max_frames
    
    # FRAME HANDLING

    @lru_cache(maxsize=128)
    def get_current_frame(self):
        return self.frames[self.curr_frame]
    
    # MOTHODS TO GET DATA LENGTH

    @property
    def get_frames_length(self):
        return len(self.frames)
    
    @property
    def get_audio_data_length(self):
        return len(self.audio_data)
    
    @property
    def get_annotations_length(self):
        return len(self.annotations)

    # METHODS TO ADD DATA

    def add_curr_frame(self, timestamp, frame):
        if frame >= self.frame_count:
            logger.warning(f"Frame index {frame} is out of range.")
        self.frames.append((timestamp, frame))

    def add_audio_data(self, timestamp, audio):
        self.audio_data.append((timestamp, audio))

    def add_annotation(self, command, annotation):
        """Adds annotations with timestamp, potentially expensive if called frequently"""
        if self.get_frames_length == 0:
            logger.error("No frames to annotate.")
            return

        frame_idx = self.get_frames_length - 1
        if frame_idx in self.annotations and self.annotations[frame_idx][0] == "start":
            self.annotations[frame_idx] = ["start", list(annotation)]
        else: self.annotations[frame_idx] = [command, list(annotation)]

        logger.debug(f"Added annotation at frame {frame_idx} with command {command}")

    # METHODS TO UPDATE DATA

    def update(self, in_path, out_path, name, frame_width, frame_height, fps, fc, sample_rate, channels):
        self.in_path = in_path
        self.out_path = out_path
        self.name = name

        self.in_file_path = os.path.join(in_path, name)
        self.out_file_path = os.path.join(out_path, name)

        self.frame_rate = fps
        self.frame_count = fc
        self.frame_width = frame_width
        self.frame_height = frame_height

        self.sample_rate = sample_rate
        self.channels = channels

        logger.info(f"Data() updated for {name}: in_path={in_path}, out_path={out_path}, frame_width={frame_width}, frame_height={frame_height}")

    def update_curr_frame(self, frame):
        self.curr_frame = frame

    def update_max_frames(self, frame):
        self.max_frames = frame

    def increment_max_frame(self):
        self.max_frames += 1

    # METHODS TO COMBINE DATA

    def identify_video_gaps(self, threshold=0.1):
        """Identify gaps in video frames where the time difference exceeds the threshold."""
        video_gaps = []
        for i in range(1, len(self.frames)):
            previous_time, _ = self.frames[i - 1]
            current_time, _ = self.frames[i]
            if current_time - previous_time > threshold:
                video_gaps.append((previous_time, current_time))
        return video_gaps

    def combined_audio(self):
        """Combines all audio data into a single array, removing audio during video gaps."""
        video_gaps = self.identify_video_gaps()
        
        synced_audio = []
        current_audio_index = 0

        for gap_start, gap_end in video_gaps:
            # Add audio before the gap
            while current_audio_index < len(self.audio_data) and self.audio_data[current_audio_index][0] < gap_start:
                synced_audio.append(self.audio_data[current_audio_index][1])
                current_audio_index += 1
            
            # Skip audio during the gap
            while current_audio_index < len(self.audio_data) and self.audio_data[current_audio_index][0] < gap_end:
                current_audio_index += 1

        # Add remaining audio after the last gap
        while current_audio_index < len(self.audio_data):
            synced_audio.append(self.audio_data[current_audio_index][1])
            current_audio_index += 1

        if synced_audio:
            combined_audio = np.concatenate(synced_audio, axis=0)
            logger.debug("Combined audio data successfully")
            return combined_audio
        else:
            logger.error("Synced audio is empty or invalid.")
            return np.array([])

    # METHODS TO SAVE DATA

    def process_video_data(self, progress=None):
        if not self.frames:
            messagebox.showerror("Error", "No frames to save.")
            logger.error("No frames to save")
            return

        # open the video file
        cap = cv2.VideoCapture(self.in_file_path)

        # check if the video file is opened
        if not cap.isOpened():
            messagebox.showerror("Error", "Failed to open video file.")
            logger.error("Failed to open video file")
            return
        
        # read the video file frame by frame
        vid, fr_cnt = [], 0
        while True:
            ret, frame = cap.read()
            if not ret:
                break
            vid.append(frame)
            fr_cnt += 1

        # Get original video properties
        original_fps = cap.get(cv2.CAP_PROP_FPS)
        original_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        original_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

        # Assert that the original properties match the given values
        assert original_fps == self.frame_rate, f"FPS mismatch: {original_fps} != {self.frame_rate}"
        assert original_width == self.frame_width, f"Frame width mismatch: {original_width} != {self.frame_width}"
        assert original_height == self.frame_height, f"Frame height mismatch: {original_height} != {self.frame_height}"
        assert fr_cnt == self.frame_count, "Frame count mismatch"

        cap.release()

        fourcc = cv2.VideoWriter_fourcc(*'mp4v')
        out = cv2.VideoWriter(self.out_file_path, fourcc, self.frame_rate, (self.frame_width, self.frame_height))

        # Write frames to the output video in the specified order
        last_index = len(self.frames) - 1
        for timestamp, index in self.frames:
            if index < len(vid):
                out.write(vid[index])
                if progress: progress.update_video_progress(index / last_index)
            else:
                logger.warning(f"Frame index {index} is out of range.")

        logger.info(f"Video data processed and saved to {self.out_file_path}")

    def process_audio_data(self, progress=None):
        # Check if audio data and annotations are present
        if len(self.audio_data) > 0:
            write(self.audio_path, self.sample_rate, self.combined_audio())
            logger.info(f"Audio data saved to {self.audio_path}")
            if progress: progress.update_audio_progress(1.0)
        else: logger.warning("No audio data to save")

    def save_av_and_clean(self, progress=None):
        """Merge audio and video data using FFmpeg"""
        subprocess.run([
            'ffmpeg',
            '-hide_banner',
            '-y',
            '-i', self.out_file_path,
            '-i', self.audio_path,
            '-c:v', 'copy',
            '-c:a', 'aac',
            '-strict', 'experimental',
            self.out_file_path.replace('.mp4', '_annotated.mp4')
        ])

        if progress: progress.update_av_progress(1.0)
        logger.info(f"Audio and video merged and saved to {self.out_file_path.replace('.mp4', '_annotated.mp4')}")

        # delete the audio and video data at self.out_file_path and self.audio_path
        if os.path.exists(self.out_file_path):
            os.remove(self.out_file_path)
            logger.debug(f"Deleted temporary video file {self.out_file_path}")
        if os.path.exists(self.audio_path):
            os.remove(self.audio_path) 
            logger.debug(f"Deleted temporary audio file {self.audio_path}")

    def save_annotations(self, progress=None):
        # add metadata to the annotations file
        self.annotations["metadata"] = {
            "video_name": self.name,
            "frame_rate": self.frame_rate,
            "frame_count": self.max_frames,
            "frame_width": self.frame_width,
            "frame_height": self.frame_height,
            "sample_rate": self.sample_rate,
            "channels": self.channels
        }

        """Save annotations to a JSON file"""
        try:
            with open(self.out_file_path.replace('.mp4', '_annotated.json'), "w") as file:
                json.dump(self.annotations, file)

            if progress: progress.update_json_progress(1.0)
            logger.info(f"Annotations saved to {self.out_file_path.replace('.mp4', '_annotated.json')}")
        except Exception as e: logger.error(f"Error saving annotations: {e}")

    def save_data(self, app):
        """Function to save video and audio, and merge them using FFmpeg"""
        if not self.out_path:
            self.out_path = filedialog.askdirectory(filetypes=[("MP4 files", "*.mp4")])

        logger.info(f"Saving data for {self.name} to {self.out_path}")

        # Create progress window
        progress = SaveProgress(app, self.name)
        progress.update()

        # Save video data
        self.process_video_data(progress=progress)

        # Save audio data
        self.process_audio_data(progress=progress)

        # Cleanup
        self.save_av_and_clean(progress=progress)

        # Save annotations
        self.save_annotations(progress=progress)

        # update progress window title
        progress.update_title_on_save()
        logger.info(f"Data for {self.name} saved successfully")

    # METHODS TO DELETE DATA

    def clean(self):
        """Function to clean the data object"""
        self.frames = []
        self.audio_data = []
        self.annotations = {}
        self.curr_frame = 0
        self.max_frame = 0
        logger.debug("Data object cleaned")

|||||||||||||		File: logging_config.yaml		|||||||||||||
version: 1

disable_existing_loggers: False

formatters:
  detailed:
    format: '[%(asctime)s]-(%(pathname)s)-(%(name)s)-{%(levelname)s}-[%(lineno)d] : %(message)s'
  simple:
    format: '%(name)s - %(levelname)s - %(message)s'

handlers:
  debug_console:
    class: logging.StreamHandler
    level: DEBUG
    formatter: simple
    stream: ext://sys.stdout

  debug_file:
    class: logging.FileHandler
    level: DEBUG
    formatter: detailed
    filename: app.log
    mode: 'a'

  info_file:
    class: logging.FileHandler
    level: INFO
    formatter: simple
    filename: info.log

  error_file:
    class: logging.FileHandler
    formatter: detailed
    level: ERROR
    filename: errors.log

  critical_file:
    class: logging.FileHandler
    formatter: detailed
    level: CRITICAL
    filename: critical.log

  # email:
  #   class: logging.handlers.SMTPHandler
  #   mailhost: 'localhost'
  #   fromaddr: 'app@example.com'
  #   toaddrs: ['admin@example.com']
  #   subject: 'Critical Error in Application'
  #   credentials: [username, password]
  #   level: CRITICAL

loggers:
  app:
    level: DEBUG
    handlers: [debug_console, debug_file, info_file, error_file, critical_file]
    propagate: no
root:
  level: WARNING
  handlers: [console]


|||||||||||||		File: main.py		|||||||||||||
# General Imports
import logging, logging.config, yaml
import customtkinter as ctk
from screens import Splash

# Custom Imports
from annotater.anno import create_annotater

# TODO: test Surface audio signal
# TODO: test annotations recorded 240p and recoreded in 1080p, scaled down to 240p

# Set up logging
def setup_logging(config_path="logging_config.yaml"):
    with open(config_path, "r") as f:
        config = yaml.safe_load(f.read())
    logging.config.dictConfig(config=config)
    logger = logging.getLogger('app')
    return logger

logger = setup_logging()

# run main loop
if __name__ == "__main__":
    logger.info("Starting the Annotation Tool...")

    try:
        # Set the theme (optional)
        ctk.set_appearance_mode("Dark")  # Can be "Dark" or "Light"
        logger.debug("Appearance mode set to Dark")

        # Create the main application window
        app = ctk.CTk()
        app.title("Annotater") # Set the title of the window
        app.protocol("WM_DELETE_WINDOW", lambda: app.destroy())
        logger.debug("Main application window created and configured")

        # Hide the main application window initially
        app.withdraw()
        logger.debug("Main application window hidden")

        # Show splash screen
        splash = Splash(app)
        logger.info("Splash screen displayed")

        create_annotater(app)
        logger.info("Annotater created and started")

    except Exception as e: logger.exception("An error occurred in the main loop: %s", e)
    finally: logger.info("Application terminated")


|||||||||||||		File: screens.py		|||||||||||||
# General Imports
import logging
import os, customtkinter as ctk
from PIL import Image

# Set up logging
logger = logging.getLogger('app')

class Splash(ctk.CTkToplevel):
    def __init__(self, root):
        super().__init__(root)
        self.root = root
        logger.debug("Initializing Splash screen")
        self.create_splash()
        self.bind("<Configure>", self.update_window_position)
        self.update_countdown(3)

    def create_splash(self):
        self.title("Loading...")

        # Center the splash screen
        self.screen_width = self.winfo_screenwidth()
        self.screen_height = self.winfo_screenheight()
        self.window_width = int(self.screen_width // 3)
        self.window_height = int(self.screen_height // 2)
        self.position_top = (self.screen_height // 2) - (self.window_height // 2)
        self.position_right = (self.screen_width // 2) - (self.window_width // 2)
        self.geometry(f"{self.window_width}x{self.window_height}+{self.position_right}+{self.position_top}")

        # Make the splash screen topmost
        self.attributes("-topmost", True)
        logger.debug(f"Splash screen centered at position: {self.position_right}, {self.position_top}")

        # Load and resize the image
        self.image_path = "./imgs/jhu.png"
        self.max_image_width = self.window_width - 40  # Max width for the image with padding
        self.max_image_height = self.window_height // 2  # Max height for the image

        if os.path.exists(self.image_path):
            img = Image.open(self.image_path)
            img_width, img_height = img.size
            logger.debug(f"Original Image Size: {img_width}x{img_height}")

            # Scale down the image if it is too big
            if img_width > self.max_image_width or img_height > self.max_image_height:
                scaling_factor = min(self.max_image_width / img_width, self.max_image_height / img_height)
                new_width = int(img_width * scaling_factor)
                new_height = int(img_height * scaling_factor)
                img = img.resize((new_width, new_height), Image.Resampling.LANCZOS)
                logger.debug(f"Resized Image Size: {new_width}x{new_height}")

            img_ctk = ctk.CTkImage(img, size=(img.width, img.height))  # Convert to CTkImage
            self.image_label = ctk.CTkLabel(self, text="", image=img_ctk)  # Create and place the image label
            self.image_label.pack(pady=20)
        else:
            print(f"Image not found: {self.image_path}")

        # Create and place the text label
        self.label = ctk.CTkLabel(self, text="Welcome to the Annotater Application", font=("Arial", 16))
        self.label.pack(pady=10)

        self.countdown_label = ctk.CTkLabel(self, text="Closing in 3 seconds", font=("Courier", 12))
        self.countdown_label.pack(pady=10)

        self.window_position_label = ctk.CTkLabel(self, text=f"Window Position: {self.winfo_x()}, {self.winfo_y()}")
        self.window_position_label.pack(pady=2)
        logger.debug("Splash screen layout created")

    def update_countdown(self, count):
        if count > 0:
            self.countdown_label.configure(text=f"Closing in {count} seconds...")
            logger.debug(f"Countdown updated to {count} seconds")
            self.after(1000, self.update_countdown, count-1)
        else:
            self.destroy_splash()

    def update_window_position(self, event):
        self.window_position_label.configure(text=f"Window Position: {self.winfo_x()}, {self.winfo_y()}")

    def destroy_splash(self):
        self.destroy()
        self.root.deiconify()    # Show the main window
        logger.info("Countdown finished, destroying splash screen, showing main window")

class SaveProgress(ctk.CTkToplevel):
    def __init__(self, root, name):
        super().__init__(root)
        self.root = root
        self.name = name
        logger.debug(f"Initializing SaveProgress window for {name}")
        self.create_save_progress()
        self.protocol("WM_DELETE_WINDOW", self.destroy_save_progress)

    def create_save_progress(self):
        self.title(f"{self.name}: Saving Progress...")
        self.geometry("400x250")
        self.attributes("-topmost", True)

        # video data progress bar
        self.video_progress = ctk.CTkProgressBar(self, mode='determinate')
        self.video_progress.pack(pady=10)
        self.video_progress_label = ctk.CTkLabel(self, text="Video Data Save Progress...")
        self.video_progress_label.pack(pady=5)

        # audio data progress bar
        self.audio_progress = ctk.CTkProgressBar(self, mode='determinate')
        self.audio_progress.pack(pady=10)
        self.audio_progress_label = ctk.CTkLabel(self, text="Audio Data Save Progress...")
        self.audio_progress_label.pack(pady=5)

        # audio-video data progress bar
        self.av_progress = ctk.CTkProgressBar(self, mode='determinate')
        self.av_progress.pack(pady=10)
        self.av_progress_label = ctk.CTkLabel(self, text="Audio-Video Data Save Progress...")
        self.av_progress_label.pack(pady=5)

        # annotations json data progress bar
        self.json_progress = ctk.CTkProgressBar(self, mode='determinate')
        self.json_progress.pack(pady=10)
        self.json_progress_label = ctk.CTkLabel(self, text="JSON Data Save Progress...")
        self.json_progress_label.pack(pady=5)

        # reset progress bars
        self.reset()
        logger.debug("SaveProgress window layout created")

    def update_title_on_save(self):
        self.title(f"{self.name}: Progress Saved!!!")
        logger.info(f"Annotations saved for {self.name}")

    def update_video_progress(self, value):
        self.video_progress.set(value)

    def update_audio_progress(self, value):
        self.audio_progress.set(value)

    def update_av_progress(self, value):
        self.av_progress.set(value)

    def update_json_progress(self, value):
        self.json_progress.set(value)

    def reset(self):
        self.title(f"{self.name}: Saving Progress...")
        self.update_video_progress(0.0)
        self.update_audio_progress(0.0)
        self.update_av_progress(0.0)
        self.update_json_progress(0.0)
        logger.debug(f"Progress bars reset for {self.name}")

    def destroy_save_progress(self):
        logger.info("Destroying SaveProgress window")
        self.destroy()
        self.root.deiconify()    # Show the main window
        logger.debug("Main window deiconified")



|||||||||||||		File: annotater\anno.py		|||||||||||||
# General Imports
import threading, logging
import customtkinter as ctk
from tkinter import filedialog

# Local Imports
from annotater.setup import file_setup, change_directory
from annotater.player import VideoPlayer, AnnotatedPlayer
from config import config

# Set up logging
logger = logging.getLogger('app')

def annotate(app, current_file_label):
    file_name = config.fetch_top_file
    if not file_name:
        current_file_label.configure(text="All files have been annotated.")
        logger.debug("All files have been annotated.")
    else:
        logger.info(f"Starting annotation for file: {file_name}")
        done_event = threading.Event()

        try:
            player = VideoPlayer(app, file_name, done_event=done_event)
            done_event.wait()
            _ = config.refetch_files()
            current_file_label.configure(text=f"Current File to be Annotated: {config.fetch_top_file}")
            logger.info(f"Annotation completed for file: {file_name}")
        except Exception as e:
            logger.exception(f"Error during annotation for file: {file_name}: {e}")

def refresh(current_file_label):
    try:
        _ = config.refetch_files()
        current_file_label.configure(text=f"Current File to be Annotated: {config.fetch_top_file}")
        logger.info("File list refreshed")
    except Exception as e:
        logger.exception(f"Error refreshing file list: {e}")

def watch():
    try:
        # get which file to watch
        watch_file = filedialog.askopenfilename(filetypes=[("MP4 files", "*.mp4")], title="Select a file to watch", initialdir=config.out_path)
        if watch_file:
            meta_file = watch_file.replace("_annotated.mp4", "_annotated.json")
            logger.info(f"Started watching file: {watch_file}")
            annoPlayer = AnnotatedPlayer(watch_file, meta_file)
        else:
            logger.warning("No file selected for watching")
    except Exception as e:
        logger.exception(f"Error during watching: {e}")

# Functions
def create_annotater(app):
    logger.info("Creating annotater")
    try:
        app.iconbitmap("./imgs/tool.ico")

        # add default styling options
        ctk.set_default_color_theme("dark-blue")  # Set the default color theme
        app.option_add("*Font", "Courier 12")  # Set the default font and size
        logger.debug("Default styling options set")

        # Set geometry to the full screen
        screen_width = 400
        screen_height = 350
        offset = 1/4
        geo = f"{screen_width}x{screen_height}+{int(offset*screen_width)}+{int(offset*screen_height)}"
        # geo = f"{screen_width}x{screen_height}-9-9"
        logger.debug(f"Geometry: {geo}")
        app.geometry(geo)

        # Setup Files
        file_setup()
        logger.info("File setup completed")
        
        # Add a label to the window
        change_dir_button = ctk.CTkButton(app, text="Change Directory", command=change_directory)
        change_dir_button.pack(pady=20)

        # Add label for the current file name
        current_file_label = ctk.CTkLabel(app, text=f"Current File to be Annotated: {config.fetch_top_file}")
        current_file_label.pack(pady=20)

        # Open Video Player Button
        video_button = ctk.CTkButton(app, text="Begin Annotating", command=lambda: annotate(app, current_file_label))
        video_button.pack(pady=20)

        # Button to refresh files
        refresh_button = ctk.CTkButton(app, text="Refresh Files", command=lambda: refresh(current_file_label))
        refresh_button.pack(pady=20)

        watch_button = ctk.CTkButton(app, text="Watch Annotated Video", command=lambda: watch())
        watch_button.pack(pady=20)

        logger.info("Annotater UI setup completed")

        # Start the main application loop
        app.mainloop()
        logger.info("Main application loop started")
    except Exception as e:
        logger.exception(f"An error occurred during annotater creation: {e}")

|||||||||||||		File: annotater\controller.py		|||||||||||||

# General imports
import cv2, logging
import customtkinter as ctk
from tkinter import DoubleVar

# Set up logging
logger = logging.getLogger('app')

class ControlWindow(ctk.CTkToplevel):
    def __init__(self, app, file_name, video_player, *args, **kwargs):
        super().__init__(app, *args, **kwargs)
        self.video_player = video_player
        self.title(f"Video Controls: {file_name}")

        self.control_frame = ctk.CTkFrame(self)
        self.control_frame.pack(pady=10)
        
        self.play_pause_button = ctk.CTkButton(self.control_frame, text="▐▐", command=self.toggle_pause)
        self.play_pause_button.grid(row=0, column=0, padx=5)
        
        self.seek_var = DoubleVar()
        self.seeker = ctk.CTkSlider(self.control_frame, variable=self.seek_var, from_=0, to=int(self.video_player.cap.get(cv2.CAP_PROP_FRAME_COUNT)), command=self.seek)
        self.seeker.grid(row=0, column=1, padx=5, sticky="ew")

        self.restart_button = ctk.CTkButton(self.control_frame, text="⟳", command=self.restart)
        self.restart_button.grid(row=0, column=2, padx=5)

        self.stop_button = ctk.CTkButton(self.control_frame, text="⏹", command=self.save_and_close)
        self.stop_button.grid(row=0, column=3, padx=5)

        self.columnconfigure(1, weight=1)
        self.protocol("WM_DELETE_WINDOW", self.close)
        
        # Make the control window screen topmost
        self.attributes("-topmost", True)
        logger.info(f"Control window configuration completed for file: {file_name}")

    def add_to_queue(self, command):
        self.video_player.command_queue.put(command)
        logger.debug("Added command to queue: %s", command)

    def toggle_pause(self):
        self.play_pause_button.configure(text="▶" if self.video_player.paused else "▐▐")
        self.add_to_queue('pause')
        logger.info("Toggled pause state to %s", not self.video_player.paused)

    def seek(self, value):
        frame_number = int(value)
        self.add_to_queue(('seek', frame_number))
        self.seek_var.set(frame_number)
        logger.info("Seeked to frame number: %d", frame_number)

    def restart(self):
        self.add_to_queue('restart')
        self.play_pause_button.configure(text="▐▐")
        self.seek_var.set(0)
        logger.info("Restarted video")

    def save_and_close(self):
        self.attributes("-topmost", False)
        self.video_player.close(save=True)
        self.video_player.done_event.set()
        logger.info("Saved and closed the video player")

    def close(self):
        self.video_player.close()
        self.video_player.done_event.set()
        logger.info("Closed the video player")

|||||||||||||		File: annotater\player.py		|||||||||||||
# General Imports
import cv2, os, threading, queue, json, logging
from tqdm import tqdm
from tkinter import messagebox
import sounddevice as sd, time as t
from ffpyplayer.player import MediaPlayer

# Local Imports
from data import Data
from config import config
from annotater.controller import ControlWindow

# Set up logging
logger = logging.getLogger('app')

class VideoPlayer:
    def __init__(self, app, file_name, done_event):
        # Video Player Objects
        self.app = app
        self.cap, self.frame, self.ret = None, None, None
        self.done_event = done_event  # Event to signal completion

        # Variables
        self.file_path, self.file_name = config.in_path, file_name
        self.cwd, self.out_path = os.getcwd(), config.out_path
        self._data = None
        self.last_frame, self.last_frame_idx, self.last_point = None, None, None

        # FLags
        self.paused, self.drawing = False, False
        self.start_counter, self.pause_frame = None, None

        # widgets
        self.control_window, self.control_frame = None, None
        self.play_pause_button, self.seeker = None, None

        # Queue for thread-safe communication
        self.command_queue = queue.Queue()
        
        # Lock for thread-safe data updates
        self.lock = threading.Lock()

        # check if file exists
        if not os.path.exists(f"{self.file_path}\{self.file_name}"):
            logger.error(f"File not found: {file_name}")
            messagebox.showerror("Error", "File not found.")
            return
        else:
            # Open the video player
            self.cap = cv2.VideoCapture(f"{self.file_path}\{self.file_name}")
            if not self.cap.isOpened():
                logger.error(f"Failed to open video file: {file_name}")
                messagebox.showerror("Error", "Failed to open video file.")
                return
            logger.info(f"Video file opened: {file_name}")
            
        # get last frame and its index
        self.last_frame_idx = int(self.cap.get(cv2.CAP_PROP_FRAME_COUNT)) - 1
        self.cap.set(cv2.CAP_PROP_POS_FRAMES, self.last_frame_idx)
        _, self.last_frame = self.cap.read()
        self.last_frame_idx, self.curr_frame_idx = None, None
        
        # reset cap to the first frame
        self.cap.set(cv2.CAP_PROP_POS_FRAMES, 0)

        # Audio variables
        self.samplerate = 44100
        self.channels = 2

        self._data = Data(
            in_path=self.file_path, out_path=self.out_path,
            name=self.file_name, 
            frame_width=int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH)), 
            frame_height=int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT)), 
            fps=int(self.cap.get(cv2.CAP_PROP_FPS)), 
            fc=int(self.cap.get(cv2.CAP_PROP_FRAME_COUNT)),
            sample_rate=self.samplerate, channels=self.channels)
        
        self.frame_delay = int((1 / self._data.frame_rate) * 1000)

        # set up audio stream
        # self.audio_stream = sd.InputStream(samplerate=self.samplerate, channels=self.channels, callback=self.audio_callback)

        # set up video player
        self.video_thread = threading.Thread(target=self.main_loop, daemon=True)

        # Ensure control window is only set up once
        self.control_window = ControlWindow(self.app, self.file_name, self)

        # Start the video player thread
        self.video_thread.start()

        logger.info("VideoPlayer initialized with frame delay: %d ms", self.frame_delay)

        # Start the control window
        self.control_window.mainloop()

    def audio_callback(self, indata, frames, time, status):
        if self.start_counter is None:
            self.start_counter = t.perf_counter()
        timestamp = t.perf_counter() - self.start_counter
        self._data.add_audio_data(timestamp, indata.copy())
        logger.debug("Audio data added at timestamp: %f", timestamp)

    def mouse_callback(self, event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN and not self.drawing:
            self.drawing = True
            self._data.add_annotation("start", (x, y))
            logger.debug("Started drawing annotation at: (%d, %d)", x, y)
        elif event == cv2.EVENT_MOUSEMOVE and self.drawing:
            self._data.add_annotation("move", (x, y))
        elif event == cv2.EVENT_LBUTTONUP and self.drawing:
            self.drawing = False
            self._data.add_annotation("end", (x, y))
            logger.debug("Ended drawing annotation at: (%d, %d)", x, y)

    def draw_annotations(self):
        """Draw annotations on the given frame based on the frame index."""
        _annotation = self._data.get_last_annotation()
        largest_key = max(self._data.annotations.keys())
        if _annotation is not None and abs(largest_key - self._data.get_frames_length) <= 5:
            command, (x, y) = _annotation
            if command == "start":
                self.start_point = (x, y)
            elif command == "move":
                cv2.line(self.frame, self.start_point, (x, y), (0, 0, 255), 3)
                self.start_point = (x, y)
            elif command == "end":
                cv2.line(self.frame, self.start_point, (x, y), (0, 0, 255), 3)
                self.start_point = None
                self.drawing = False
            logger.debug("Annotations drawn on frame")

    def main_loop(self):
        cv2.namedWindow("Video Player")
        cv2.setMouseCallback("Video Player", self.mouse_callback)

        total_frames = self._data.get_max_frames
        self.start_counter = t.perf_counter()  # Start high-resolution timer

        # start audio stream
        with sd.InputStream(samplerate=self.samplerate, channels=self.channels, callback=self.audio_callback):
            with tqdm(total=total_frames, desc="Processing Frames") as self.pbar:
                while self.cap.isOpened():
                    start_time = t.time()
                    current_counter = t.perf_counter() - self.start_counter

                    self.curr_frame_idx = curr_frame = int(self.cap.get(cv2.CAP_PROP_POS_FRAMES))
                    if curr_frame >= total_frames: curr_frame = total_frames - 1
                    
                    # update seeker
                    self.control_window.seek_var.set(curr_frame)

                    # Check for commands
                    try:
                        command = self.command_queue.get_nowait()

                        if command == 'pause': self.toggle_pause()
                        elif isinstance(command, tuple) and command[0] == 'seek': self.seek(command[1])
                        elif command == 'restart': self.restart()

                    except queue.Empty:
                        pass
                    
                    # Check for pause
                    if not self.paused:
                        self.ret, self.frame = self.cap.read()
                        if not self.ret: 
                            self.pbar.total += 1
                            self.frame = self.last_frame.copy()
                        self.pause_frame = self.frame.copy()
                    else:
                        self.frame = self.pause_frame.copy()
                        self.pbar.total += 1
                        self._data.increment_max_frame()

                    if self.drawing: self.draw_annotations()

                    # Display the frame
                    cv2.imshow("Video Player", self.frame)

                    # add current frame to data
                    self._data.add_curr_frame(current_counter, curr_frame)

                    # Check for key press
                    key = cv2.waitKey(1) & 0xFF

                    # Update progress bar
                    self.pbar.update(1)

                    # Update frame delay
                    elapsed_time = t.time() - start_time
                    remaining_time = max(0, self.frame_delay / 1000 - elapsed_time)  # Convert frame_delay to seconds
                    if remaining_time > 0:
                        t.sleep(remaining_time)

                logger.info("Video processing completed")

    def toggle_pause(self):
        self.paused = not self.paused

    def seek(self, frame_number):
        self.cap.set(cv2.CAP_PROP_POS_FRAMES, frame_number)
        self._data.update_curr_frame(frame_number)
        self.curr_frame_idx = frame_number

    def restart(self):
        # Reset the video player
        self.paused, self.drawing = False, False

        # reset cap to the first frame
        self.cap.set(cv2.CAP_PROP_POS_FRAMES, 0)

        # clean data
        self._data.clean()
        self._data.update_max_frames(int(self.cap.get(cv2.CAP_PROP_FRAME_COUNT)))
        self._data.update(
            in_path=self.file_path, out_path=self.out_path,
            name=self.file_name, 
            frame_width=int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH)), 
            frame_height=int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT)), 
            fps=int(self.cap.get(cv2.CAP_PROP_FPS)), 
            fc=int(self.cap.get(cv2.CAP_PROP_FRAME_COUNT)),
            sample_rate=self.samplerate, channels=self.channels)
        
        # clear command queue
        while not self.command_queue.empty():
            _ = self.command_queue.get()
        logger.info("Command queue cleared and video restarted")

        # Reset tqdm progress bar
        self.pbar.reset(total=int(self.cap.get(cv2.CAP_PROP_FRAME_COUNT)))
        self.pbar.refresh()

    def close(self, save=False):
        # relese video capture and stop audio stream
        self.cap.release()
        sd.stop()

        # save data if required
        if save: self._data.save_data(self.app)

        # close windows and threads
        cv2.destroyAllWindows()
        self.done_event.set()
        self.video_thread.join(1)
        self.control_window.quit()
        self.control_window.destroy()
        self.app.deiconify()
        logger.info("VideoPlayer closed")

class AnnotatedPlayer:
    def __init__(self, watch_file, meta_file):
        logger.info(f"Initializing AnnotatedPlayer for file: {watch_file}")

        self.watch_file = watch_file
        self.meta_file = meta_file

        if not os.path.exists(watch_file):
            logger.error(f"File not found: {watch_file}")
            messagebox.showerror("Error", "File not found.")
            return
        else:
            self.cap = cv2.VideoCapture(watch_file)
            if not self.cap.isOpened():
                logger.error(f"Failed to open watch file: {watch_file}")
                messagebox.showerror("Error", "Failed to open video file.")
                return
            logger.info(f"Watch file opened: {watch_file}")

        if not os.path.exists(meta_file):
            logger.error(f"File metadata not found: {meta_file}")
            messagebox.showerror("Error", "File metadata not found.")
            return
        else:
            self.meta = json.load(open(meta_file, "r"))
            logger.info(f"Metadata file opened: {meta_file}")

        self.player  = MediaPlayer(watch_file)
        self.audio_on = True

        self.start_time = None
        self.last_point = None

        self.total_frames = int(self.cap.get(cv2.CAP_PROP_FRAME_COUNT))
        self.frame_rate = self.meta['metadata']['frame_rate']
        self.frame_delay = int((1 / self.frame_rate) * 1000)

        self.show()

    def show(self):
        # open video player and display annotations
        cv2.namedWindow("Annotater Player")
        logger.info(f"Started Annotated Player for file: {self.watch_file}")

        while self.cap.isOpened():
            ret, frame = self.cap.read()
            if self.audio_on: audio_frame, val = self.player.get_frame()
            
            if ret:
                frame_number = int(self.cap.get(cv2.CAP_PROP_POS_FRAMES))
                if str(frame_number) in self.meta:
                    action, point = self.meta[str(frame_number)]
                    if action == "start":
                        self.last_point = tuple(point)
                    elif action == "move":
                        cv2.line(frame, self.last_point, tuple(point), (0, 0, 255), 3)
                        self.last_point = tuple(point)
                    elif action == "end":
                        cv2.line(frame, self.last_point, tuple(point), (0, 0, 255), 3)
                        self.last_point = None

                if self.audio_on and val != 'eof' and audio_frame is not None: _, t = audio_frame
                elif val == 'eof': 
                    self.audio_on = False
                    continue

                cv2.imshow("Annotater Player", frame)
                if cv2.waitKey(self.frame_delay) & 0xFF == ord('q'): break
            else: break

        self.close()
        logger.info("Annotater Player closed")

    def close(self):
        self.cap.release()
        self.player.close_player()
        cv2.destroyAllWindows()
        logger.info("AnnotatedPlayer resources released and windows closed")

|||||||||||||		File: annotater\setup.py		|||||||||||||
# General Imports
import os, logging
from customtkinter import filedialog
from tkinter import messagebox

# Local Imports
from config import config

# Set up logging
logger = logging.getLogger('app')

def file_setup():
    logger.info("Starting file setup")

    try:
        # get current working directory
        cwd = os.getcwd()
        logger.debug(f"Current working directory: {cwd}")
        
        # Select Input Video Directory
        if not os.path.exists(f"{cwd}\data"): 
            in_path = filedialog.askdirectory(title="Select Input Directory", initialdir=cwd)
            logger.info(f"Input directory selected: {in_path}")
        else: 
            in_path = f"{cwd}\data"
            logger.debug(f"Default input directory used: {in_path}")

        # Select Output Directory
        if not os.path.exists(f"{cwd}\out"): 
            out_path = filedialog.askdirectory(title="Select Output Directory", initialdir=cwd)
            logger.info(f"Output directory selected: {out_path}")
        else: 
            out_path = f"{cwd}\out"
            logger.debug(f"Default output directory used: {out_path}")

        # get list of names all mp4 files in self.file_path
        in_files = [f for f in os.listdir(in_path) if f.endswith(".mp4")]
        logger.info(f"Found {len(in_files)} MP4 files in the input directory")

        if len(in_files) == 0: 
            logger.warning("No MP4 files found in the input directory")
            messagebox.showerror("Error", "No MP4 files found in the input directory.")
        
        files = config.refetch_files(in_path, out_path)
        logger.info(f"Files refetched: {files}")
    except Exception as e:
        logger.error(f"An error occurred during file setup: {e}", exc_info=True)

def change_directory():
    logger.info("Starting directory change")

    try:
        new_directory = filedialog.askdirectory(title="Select New Directory")
        if new_directory:
            os.chdir(new_directory)
            logger.info(f"Current working directory changed to: {new_directory}")
            in_path, out_path, files = file_setup()
            return in_path, out_path, files, new_directory
        else:
            logger.warning("No directory selected for change")
    except Exception as e:
        logger.error(f"An error occurred during directory change: {e}", exc_info=True)

